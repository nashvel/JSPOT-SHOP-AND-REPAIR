
import { useState, useEffect, useCallback } from 'react';
import db, { OfflineReservation, OfflineProduct, OfflineSale, generateLocalId } from './db';
import { syncToServer } from './sync';

interface CreateOfflineReservationParams {
    branchId: number;
    customerName: string;
    customerContact: string | null;
    vehicleEngine: string | null;
    vehicleChassis: string | null;
    vehiclePlate: string | null;
    reservationDate: Date;
    issueDescription: string | null;
    notes: string | null;
    items: Array<{
        product: OfflineProduct;
        quantity: number;
        // Pricing can be custom if needed, but defaults to product price
    }>;
    mechanicIds: number[];
}

export function useOfflineReservations(branchId: number) {
    const [offlineReservations, setOfflineReservations] = useState<OfflineReservation[]>([]);
    const [loading, setLoading] = useState(true);

    // Refresh local reservations
    const refreshReservations = useCallback(async () => {
        setLoading(true);
        try {
            let collection = db.reservations.toCollection();

            if (branchId !== 0) {
                collection = db.reservations.where('branchId').equals(branchId);
            }

            const reservations = await collection
                .reverse()
                .sortBy('createdAt');
            setOfflineReservations(reservations);
        } catch (error) {
            console.error('[Offline] Failed to load reservations:', error);
        } finally {
            setLoading(false);
        }
    }, [branchId]);

    // Initial load
    useEffect(() => {
        refreshReservations();
    }, [refreshReservations]);

    // Create a new offline reservation
    const createReservation = async (params: CreateOfflineReservationParams): Promise<OfflineReservation> => {
        const {
            branchId,
            customerName,
            customerContact,
            vehicleEngine,
            vehicleChassis,
            vehiclePlate,
            reservationDate,
            issueDescription,
            notes,
            items,
            mechanicIds,
        } = params;

        // Generate reservation number
        const date = new Date();
        const dateStr = date.toISOString().split('T')[0].replace(/-/g, '');
        const count = await db.reservations.filter(r => r.branchId === branchId).count();
        const reservationNumber = `RES-${branchId}-${dateStr}-${String(count + 1).padStart(4, '0')}`;

        const newReservation: OfflineReservation = {
            id: generateLocalId(),
            serverId: null,
            reservationNumber,
            branchId,
            customerName,
            customerContact,
            vehicleEngine,
            vehicleChassis,
            vehiclePlate,
            reservationDate,
            issueDescription,
            notes,
            status: 'pending',
            items: items.map(item => ({
                id: generateLocalId(),
                reservationId: '', // placeholder, set below
                productId: item.product.id,
                productName: item.product.name,
                productType: item.product.type,
                categoryName: item.product.categoryName,
                quantity: item.quantity,
                unitPrice: item.product.price,
                total: item.product.price * item.quantity,
            })),
            mechanicIds,
            synced: false,
            createdAt: new Date(),
            updatedAt: new Date(),
            qrToken: null, // Will be generated by server on sync
        };

        // Fix reservationId in items
        newReservation.items.forEach(item => item.reservationId = newReservation.id);

        await db.reservations.add(newReservation);
        await refreshReservations();

        // Try to sync if online
        if (navigator.onLine) {
            syncToServer().catch(console.error);
        }

        return newReservation;
    };

    // Update status locally
    const updateStatus = async (id: string, status: OfflineReservation['status']) => {
        const reservation = await db.reservations.get(id);
        if (!reservation) return;

        // Create Sale/JobOrder if completed and not already handled
        if (status === 'completed' && reservation.status !== 'completed') {
            // Generate Sale Number
            const date = new Date();
            const dateStr = date.toISOString().split('T')[0].replace(/-/g, '');
            const count = await db.sales.filter(s => s.branchId === branchId).count();
            const saleNumber = `SALE-${branchId}-${dateStr}-${String(count + 1).padStart(4, '0')}`;

            const subtotal = reservation.items.reduce((sum, item) => sum + item.total, 0);

            // Create Offline Sale
            const saleId = generateLocalId();
            const newSale: OfflineSale = {
                id: saleId,
                serverId: null,
                saleNumber,
                branchId: reservation.branchId,
                customerId: null, // Reservation doesn't store customer ID, only name
                customerName: reservation.customerName,
                mechanicId: reservation.mechanicIds && reservation.mechanicIds.length > 0 ? reservation.mechanicIds[0] : null,
                mechanicName: 'Assigned Mechanic', // Placeholder
                items: reservation.items.map(item => ({
                    id: generateLocalId(),
                    saleId,
                    productId: item.productId || '',
                    productName: item.productName,
                    productType: item.productType,
                    categoryName: item.categoryName,
                    quantity: item.quantity,
                    unitPrice: item.unitPrice,
                    total: item.total,
                    paymentMethod: 'cash', // Default or need input
                    referenceNumber: null,
                    transactions: []
                })),
                subtotal,
                taxAmount: 0,
                discountAmount: 0,
                total: subtotal,
                amountPaid: subtotal, // Assume fully paid if completed? Or pending?
                changeAmount: 0,
                paymentMethod: 'cash',
                referenceNumber: null,
                status: 'completed',
                notes: `Generated from Reservation ${reservation.reservationNumber}`,
                synced: false,
                createdAt: new Date(),
                updatedAt: new Date(),
            };

            await db.sales.add(newSale);

            // Note: Job Order creation logic matches Sale creation logic in complexity.
            // For now, focusing on Sale as per "Complete creates sale" message.
        }

        await db.reservations.update(id, {
            status,
            synced: false,
            updatedAt: new Date()
        });
        await refreshReservations();

        if (navigator.onLine) {
            syncToServer().catch(console.error);
        }
    };

    return {
        offlineReservations,
        loading,
        refreshReservations,
        createReservation,
        updateStatus,
    };
}
